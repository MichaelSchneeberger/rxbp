import datetime
from typing import Iterable

from continuationmonad.typing import Scheduler

import reactivex

from rxbp.flowable.flowable import Flowable, ConnectableFlowable

def connectable[U](id, init: U) -> ConnectableFlowable[U]: ...
def count() -> Flowable[int]: ...
def empty() -> Flowable[None]: ...
def error() -> Flowable[None]: ...
def from_iterable[U](iterable: Iterable[U]) -> Flowable[U]: ...
def from_value[U](value: U) -> Flowable[U]: ...
def from_rx[U](source: reactivex.Observable[U]) -> Flowable[U]: ...
def interval(
    seconds: float, scheduler: Scheduler | None = None
) -> Flowable[datetime.datetime]: ...
def merge[U](observables: tuple[Flowable[U], ...]) -> Flowable[tuple[U, ...]]: ...
def repeat[U](value: U) -> Flowable[U]: ...
def schedule_on(scheduler: Scheduler | None = None) -> Flowable[Scheduler]: ...
def schedule_relative(
    duetime: float, scheduler: Scheduler | None = None
) -> Flowable[Scheduler]: ...
def schedule_absolute(
    duetime: datetime.datetime, scheduler: Scheduler | None = None
) -> Flowable[Scheduler]: ...
def zip[U](observables: tuple[Flowable[U], ...]) -> Flowable[tuple[U, ...]]: ...
