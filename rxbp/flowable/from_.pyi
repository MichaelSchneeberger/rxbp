import datetime
from typing import Iterable

from continuationmonad.typing import Scheduler

import reactivex

from rxbp.flowable.flowable import Flowable, ConnectableFlowable

def connectable[U](id, init: U) -> ConnectableFlowable[U]: ...
def count() -> Flowable[int]: ...
def empty() -> Flowable[None]: ...
def error() -> Flowable[None]: ...
def from_iterable[U](iterable: Iterable[U]) -> Flowable[U]: ...
def from_value[U](value: U) -> Flowable[U]: ...
def from_rx[U](source: reactivex.Observable[U]) -> Flowable[U]: ...
def interval(scheduler: Scheduler, interval: float) -> Flowable[datetime.datetime]: ...
def merge[U](observables: tuple[Flowable[U], ...]) -> Flowable[tuple[U, ...]]: ...
def repeat[U](value: U) -> Flowable[U]: ...
def schedule_on(scheduler: Scheduler) -> Flowable[Scheduler]: ...
def schedule_relative(scheduler: Scheduler, duetime: float) -> Flowable[Scheduler]: ...
def schedule_absolute(scheduler: Scheduler, duetime: datetime.datetime) -> Flowable[Scheduler]: ...
def zip[U](observables: tuple[Flowable[U], ...]) -> Flowable[tuple[U, ...]]: ...
