import datetime
from typing import Callable, Iterable

from continuationmonad.typing import (
    Scheduler,
    ContinuationMonad,
    ContinuationCertificate,
)

import reactivex

from rxbp.flowable.flowable import Flowable, ConnectableFlowable
from rxbp.flowabletree.observer import Observer

def connectable[U](id, init: U) -> ConnectableFlowable[U]: ...
def count() -> Flowable[int]: ...

class create[U]:
    def __new__(
        cls,
        func: Callable[
            [Observer, Scheduler], ContinuationMonad[ContinuationCertificate]
        ],
    ) -> Flowable[U]: ...

def empty() -> Flowable[None]: ...
def error() -> Flowable[None]: ...
def from_iterable[U](iterable: Iterable[U]) -> Flowable[U]: ...
def from_value[U](value: U) -> Flowable[U]: ...
def from_rx[U](source: reactivex.Observable[U]) -> Flowable[U]: ...
def interval(
    seconds: float, scheduler: Scheduler | None = None
) -> Flowable[datetime.datetime]: ...
def merge[U](observables: tuple[Flowable[U], ...]) -> Flowable[tuple[U, ...]]: ...
def repeat[U](value: U) -> Flowable[U]: ...
def schedule_on(scheduler: Scheduler | None = None) -> Flowable[Scheduler]: ...
def schedule_relative(
    seconds: float, scheduler: Scheduler | None = None
) -> Flowable[Scheduler]: ...
def schedule_absolute(
    until: datetime.datetime, scheduler: Scheduler | None = None
) -> Flowable[Scheduler]: ...
def zip[U](observables: tuple[Flowable[U], ...]) -> Flowable[tuple[U, ...]]: ...
